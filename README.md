# 🧮 절차적 vs 객체지향 계산기 프로젝트
 

## 📌 프로젝트 개요
이 프로젝트는 **클래스를 활용한 계산기**와 **클래스를 사용하지 않는 계산기** 두 가지 버전을 구현하여 객체지향 개념을 실습하고 적용한 프로젝트입니다. **절차적 프로그래밍과 객체지향 프로그래밍(OOP)의 차이점**을 비교하며  
코드의 **유지보수성과 확장성**을 고려한 설계의 장점을 경험하는 것이 목표입니다.

---

## 📆 프로젝트 기간 및 인원
- **기간** : 2024.03.04 ~ 2024.03.06
- **인원** : 1인 개발 (개인 프로젝트)

---

## 🛠️ 기술 스택
- **언어** : Java  
- **패턴** : 절차적 프로그래밍(Procedural), 객체지향 프로그래밍(OOP)  
- **입출력 방식** : 콘솔 기반 (`Scanner` 사용)  
- **컬렉션 활용** : `ArrayList<Integer>` (객체지향 버전에서 연산 결과 저장)  

---

## **☀️ 요구사항 정의와 설계**

### **🔹 클래스를 사용하지 않는 계산기 (절차적)**
1. **기능 요구사항**
   - 기본적인 사칙연산 수행 (+, -, *, /)
   - 즉시 결과 출력
   - 반복적으로 연산 수행, `exit`을 입력하면 종료됨

2. **사용자 인터페이스 방식**
   - **입력**: `Scanner`를 사용하여 숫자와 연산 기호 입력
   - **출력**: `System.out.println()`으로 결과 출력

3. **구조**
   - 하나의 `main()` 메서드에서 모든 기능 처리

4. **주요 메서드 기능**
   - `main()` : 프로그램 실행 및 연산루프 관리  
   - 'sc.nextInt()' : 숫자 입력 받기
   - 'sc.next().charAt(0)' : 연산 기호 입력 받기
   - 'sc.nextLine()' : 버퍼 비우기 용도 (개행문자 제거)
   - 'System.out.println()' : 연산 결과 및 안내 메세지 출력
   - 'sc.close()' : Scanner 객체 닫기 (리소스 정리)

5. **데이터 흐름**
   - 입력 → 연산 → 출력 → 반복/종료 

6. **예외 처리**
   - **잘못된 연산 기호 입력**:  
     `switch` 문에서 올바른 연산 기호가 입력되지 않으면 `"오류: 잘못된 연산 기호를 입력하였습니다"` 출력하고 연산 결과가 출력되지 않도록 설정  
   - **0으로 나누기**:  
     `switch` 문 속 `if` 문을 통해 `"오류: 0으로 나눗셈이 불가합니다"`를 출력하고 연산 결과가 출력되지 않도록 설정

---

### **🔹 클래스를 사용하는 계산기 (객체지향적)**
1. **기능 요구사항**
   - 기본적인 사칙연산 수행 (+, -, *, /)
   - `List`를 사용하여 연산 결과를 저장
   - `remove` 입력 시, 가장 오래된 결과 삭제
   - 반복적으로 연산 수행, `exit`을 입력하면 종료됨
   - 기능별로 클래스 분리 (`Calculator`, `Operation`, `Parser`, `App`)

2. **사용자 인터페이스 방식**
   - **입력** : `Parser` 클래스를 활용하여 입력
   - **출력** : 결과를 `List`에 저장 후, `System.out.println()`으로 출력

3. **구조**
   - `App(실행) / Parser(입력) / Operation(연산) / Calculator(연산)` 클래스로 기능 분리  

4. **주요 메서드 기능**
   - **`App` 클래스**
     - `main()` : 프로그램 실행 및 제어  
   - **`Calculator` 클래스**
     - `calculate()` : 입력값으로 연산 수행 및 저장  
     - `getResults()` : 저장한 결과를 리스트에 반환  
     - `removeResult()` : 저장한 결과 중, 첫 번째 항목 삭제  
   - **`Operation` 클래스**
     - `add()`, `subtract()`, `multiply()`, `divide()` : 각각의 사칙연산 수행  
   - **`Parser` 클래스**
     - `getNumber()`, `getOperator()`, `getNextLine()` : 사용자 입력을 받기 위함  

5. **데이터 흐름**
   1. 사용자 입력(`Parser`)  
   2. 데이터 전달(`App`에서 `Calculator`로)  
   3. 연산 수행(`Calculator`가 `Operation`을 호출하여 연산)  
   4. 연산 결과 저장(`Calculator`의 `List<Integer>`)  
   5. 출력(`App`의 `System.out.println()`)  
   6. 추가 입력 (`exit` 입력 시 `App`에서 종료 / `remove` 입력 시 `Calculator`에서 연산 결과 삭제)  
   7. 반복 실행 또는 종료 (`App`)  

6. **예외 처리**
   - **숫자 아닌 값을 입력 (`try-catch` 활용)**  
     `Parser.getNumber()` 메서드에서 `Scanner.nextInt()`를 사용할 때, 숫자가 아닌 값을 입력하면 `InputMismatchException` 발생  
     이를 `try-catch` 문으로 감싸 `"오류: 숫자를 입력해주세요"`를 출력하고, 다시 입력받도록 처리  
   - **잘못된 연산 기호 입력 (`switch` 활용)**  
     `switch` 문에서 올바른 연산 기호가 입력되지 않으면 `"오류: 잘못된 연산 기호를 입력하였습니다"` 출력  
   - **0으로 나누기 (`if` 활용)**  
     `switch` 문 속 `if` 문을 통해 `"오류: 0으로 나눗셈이 불가합니다"`를 출력하고 연산 결과가 출력되지 않도록 설정  

---

## **🌕 프로젝트 회고**
- 가이드는 Calculation 클래스에 관해서만 나와있어서 이외에 어떤 클래스가 필요할지 구성하는 것에서부터 어려움을 겪었다. 입력 / 연산 / 실행이 각각 이루어져야한다니! 객체지향적 알고리즘 사고를 더 익히기 위해 노력해야 할 것 같다. 또한 처음에 '요구사항 정의'를 작성할 때, '예외처리' 항목이 있길래 그 부분을 좀 더 신경써보려했는데도 부족한 느낌이 들어서 아쉽다. switch문이나 if문을 사용하여 논리적으로 예외 처리를 하는게 나에겐 제일 익숙했고, try-catch 방식은 익숙하지 않아서 한 번밖에 사용하지 못했다. 앞으로는 try-catch도 더 자주 사용해보고, 별도의 검증 클래스도 만들면 좋지 않을까 기대해본다.
-  단순한 기능을 빠르게 구현하는 데에는 절차적 프로그래밍이 훨씬 쉽긴 했지만, 막상 클래스를 이용한 계산기를 만들고 나니까 객체지향적 프로그래밍의 장점을 제대로 느낄 수 있었다. 객체지향 프로그래밍은 클래스별로 캡슐화 되어있다보니까 코드를 재사용하거나 유지보수하는데에 훨씬 뛰어났다. 코드도 훨씬 깔끔해지고 내 머릿속에서도 구조가 확실하게 인지된다. 절차적 프로그래밍은 비록 쉽게 끝내긴 했지만, 더 수정하려했으면 코드를 전체적으로 손봤어야 했을거고, 반대로 객체지향적 프로그래밍은 큰 사이즈임에도 불구하고 클래스별로만 수정해줘도 되니까 사이즈에 비해 큰 오류 없이 수정할 수 있었다. 큰 사이즈의 프로젝트를 할 수록 절차적 방식보다 객체지향적 접근이 훨씬 효율적이라는 것을 깨달았다. 물론 작은 프로젝트라도 객체지향적으로 코딩하면 더 편리하겠지! 절차적 코딩에서 객체지향적 코딩으로 발전해나가는 과정을 통해 객체지향의 필요성을 제대로 느낄 수 있던 프로젝트였다. 앞으로 OOP를 적극 활용해야겠다는 생각이 들었다~!
